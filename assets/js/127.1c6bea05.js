(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{445:function(t,v,_){"use strict";_.r(v);var a=_(0),e=Object(a.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"策略模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#策略模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 策略模式")]),t._v(" "),_("blockquote",[_("p",[t._v("条条道路通罗马")])]),t._v(" "),_("h2",{attrs:{id:"什么是策略模式？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是策略模式？","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是策略模式？")]),t._v(" "),_("p",[t._v("根据输入不同条件，进行不同的计算。")]),t._v(" "),_("p",[t._v("例如输入"),_("code",[t._v("+")]),t._v("进行加法，输入"),_("code",[t._v("-")]),t._v("就进行减法。")]),t._v(" "),_("p",[t._v("然后把这些计算公式封装到同一个函数内部。")]),t._v(" "),_("p",[t._v("这个函数内部根据符号进行判断的方式可以是"),_("code",[t._v("if else")])]),t._v(" "),_("h2",{attrs:{id:"实现策略模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现策略模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现策略模式")]),t._v(" "),_("p",[t._v("文中举例的例子十分简单。")]),t._v(" "),_("p",[t._v("将要复用的方法放到一个对象内部："),_("code",[t._v("var ways = {}")])]),t._v(" "),_("ol",[_("li",[t._v("实现一个"),_("code",[t._v("add")]),t._v("方法通过参数选择"),_("code",[t._v("ways")]),t._v("里面的方法注册到可以实例化的对象内部。可以使用"),_("code",[t._v("curry")]),t._v("的方式再一次封装策略中的方法。通过"),_("strong",[t._v("延迟执行策略函数")]),t._v("的方式。")])]),t._v(" "),_("p",[t._v("文中"),_("strong",[t._v("表单验证的举例很形象")]),t._v("，可以看一看。")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("将函数作为参数传递是简化策略函数的一种方式")])])])},[],!1,null,null,null);v.default=e.exports}}]);