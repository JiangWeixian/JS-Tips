(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{365:function(E,t,_){"use strict";_.r(t);var v=_(0),e=Object(v.a)({},function(){var E=this,t=E.$createElement,_=E._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":E.$parent.slotKey}},[_("h1",{attrs:{id:"课程介绍和算法分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#课程介绍和算法分析","aria-hidden":"true"}},[E._v("#")]),E._v(" 课程介绍和算法分析")]),E._v(" "),_("h2",{attrs:{id:"简单速写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单速写","aria-hidden":"true"}},[E._v("#")]),E._v(" 简单速写")]),E._v(" "),_("ul",[_("li",[E._v("编程可以用户友好可以性能优秀。性能就是基础，在性能优秀基础上得到更好的界面效果。")]),E._v(" "),_("li",[E._v("排序算法介绍")]),E._v(" "),_("li",[E._v("算法性能分析")]),E._v(" "),_("li",[E._v("简单介绍了大O计算方法(具体在第二课介绍)\n"),_("ul",[_("li",[E._v("不同复杂度算法性能比较")]),E._v(" "),_("li",[E._v("计算了插入排序的算法复杂度(和我在"),_("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md",target:"_blank",rel:"noopener noreferrer"}},[E._v("排序算法分析的一致"),_("OutboundLink")],1),E._v(")")]),E._v(" "),_("li",[E._v("计算了归并排序的算法复杂度")])])])]),E._v(" "),_("h2",{attrs:{id:"排序算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排序算法","aria-hidden":"true"}},[E._v("#")]),E._v(" "),_("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md",target:"_blank",rel:"noopener noreferrer"}},[E._v("排序算法"),_("OutboundLink")],1)]),E._v(" "),_("p",[E._v("在标题链接文档中分析。")]),E._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.js",target:"_blank",rel:"noopener noreferrer"}},[E._v("插入排序"),_("OutboundLink")],1)]),E._v(" "),_("li",[_("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.js",target:"_blank",rel:"noopener noreferrer"}},[E._v("归并排序"),_("OutboundLink")],1)])]),E._v(" "),_("h2",{attrs:{id:"性能分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能分析","aria-hidden":"true"}},[E._v("#")]),E._v(" 性能分析")]),E._v(" "),_("p",[E._v("算法分析要忽略硬件条件一些无关干扰，性能和"),_("strong",[E._v("以下几个方面")]),E._v("有关")]),E._v(" "),_("ul",[_("li",[E._v("输入情况 - 得到算法"),_("strong",[E._v("最差情况")])]),E._v(" "),_("li",[E._v("数据量 - 算法时间直接相关，因此要有"),_("strong",[E._v("算法的上限")]),E._v(" "),_("ul",[_("li",[E._v("讲数据量参数化转换为"),_("code",[E._v("n")]),E._v("，然后根据"),_("code",[E._v("n")]),E._v("来计算算法复杂度。也就是大O计数法")])])])]),E._v(" "),_("p",[_("strong",[E._v("几个算法性能指标：")])]),E._v(" "),_("ul",[_("li",[_("code",[E._v("T(n)")]),E._v(" - 最大时间比较常用\n"),_("ol",[_("li",[E._v("算法运行最大时间，具体表达式，例如"),_("code",[E._v("n^2+n")]),E._v("之类的")]),E._v(" "),_("li",[E._v("平均时间，每种情况运行时间乘以情况出现概率")])])]),E._v(" "),_("li",[E._v("算法增加时间，对于一个"),_("code",[E._v("y = n^2 or y = n")]),E._v("算法，前面一种算法复杂度增加数值比后面一种高")])]),E._v(" "),_("h3",{attrs:{id:"大o计算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大o计算法","aria-hidden":"true"}},[E._v("#")]),E._v(" 大O计算法")]),E._v(" "),_("p",[E._v("计算的时候忽略低次项以及常数项目。例如"),_("code",[E._v("3n^3+2n^2")]),E._v("在大O表示出来就是"),_("code",[E._v("O(n^3)")]),E._v("。")]),E._v(" "),_("p",[_("strong",[E._v("大O计算法原则1")])]),E._v(" "),_("p",[E._v("当n趋向于无穷，"),_("code",[E._v("O(n^2)")]),E._v("永远比"),_("code",[E._v("O(n^3)")]),E._v("优秀。")]),E._v(" "),_("p",[_("strong",[E._v("甚至在一个低性能计算机和一个高性能计算机也是成立的")])]),E._v(" "),_("p",[_("strong",[E._v("大O计算法原则2")])]),E._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/Lesson01-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/img/%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png",alt:"不同复杂度性能分析"}})]),E._v(" "),_("p",[E._v("在数据量比较低的时候，高复杂度算法也可以表现良好。")]),E._v(" "),_("h3",{attrs:{id:"具体计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#具体计算","aria-hidden":"true"}},[E._v("#")]),E._v(" 具体计算")]),E._v(" "),_("p",[_("strong",[E._v("插入排序-非递归计算")])]),E._v(" "),_("p",[E._v("非递归算法 - 以插入排序为例子。递归计算为"),_("code",[E._v("1+2+...n=(1+n)*n/2")]),E._v("，根据大O表示法只保留算法的最高次幂，所以该算法就是一个"),_("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),E._v("复杂度的算法。")]),E._v(" "),_("p",[_("strong",[E._v("归并排序-递归计算(具体可看第二课)")])]),E._v(" "),_("p",[E._v("利用递归树计算。")]),E._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/Lesson01-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/img/%E9%80%92%E5%BD%92%E6%A0%91.png",alt:"递归树"}})]),E._v(" "),_("p",[E._v("根节点假设是2的n次幂。假设是"),_("code",[E._v("8")]),E._v("，就是解决数据量为"),_("code",[E._v("8")]),E._v("的一个算法，递归树分析。")]),E._v(" "),_("p",[E._v("那么对于这个树来说：")]),E._v(" "),_("ol",[_("li",[E._v("树高是"),_("code",[E._v("logn")])]),E._v(" "),_("li",[E._v("最下面一层的叶子节点为"),_("code",[E._v("n")])])]),E._v(" "),_("p",[E._v("因为对于递归来说，要转换为最小问题求解。所以最后一层是"),_("code",[E._v("O(1)")]),E._v("问题。")]),E._v(" "),_("p",[E._v("那么算法复杂度就是"),_("code",[E._v("nlogn")])])])},[],!1,null,null,null);t.default=e.exports}}]);