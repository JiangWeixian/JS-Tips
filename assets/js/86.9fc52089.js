(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{272:function(t,_,v){"use strict";v.r(_);var r=v(0),e=Object(r.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"排序算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序算法"}},[t._v("#")]),t._v(" 排序算法")]),t._v(" "),v("blockquote",[v("p",[t._v("各种排序算法以及如何计算复杂度初探")])]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"}},[t._v("排序算法")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86---%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"}},[t._v("前置知识 - 计算算法复杂度")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"}},[t._v("插入排序")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"}},[t._v("实现流程")])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"}},[t._v("冒泡排序")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"}},[t._v("归并排序")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0%E5%AE%83"}},[t._v("实现它")])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"}},[t._v("快速排序")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0"}},[t._v("实现")])])])])]),t._v(" "),v("h2",{attrs:{id:"前置知识-计算算法复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前置知识-计算算法复杂度"}},[t._v("#")]),t._v(" 前置知识 - 计算算法复杂度")]),t._v(" "),v("p",[t._v("具体解释可见:")]),t._v(" "),v("ol",[v("li",[v("a",{attrs:{href:""}},[v("strong",[t._v("网易公开课-算法导论-第2课")])])]),t._v(" "),v("li",[v("a",{attrs:{href:"https://zh.wikipedia.org/zh-hans/%E5%A4%A7O%E7%AC%A6%E5%8F%B7",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-大O表示法"),v("OutboundLink")],1)])]),t._v(" "),v("p",[t._v("大致解释一下：")]),t._v(" "),v("p",[t._v("算法复杂度就是"),v("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),t._v(" 表示，括号内会变。只是一种近视表示，表示的是算法复杂度的"),v("strong",[t._v("上限")]),t._v("，意味着小于等于这个算法复杂度。就像是是"),v("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),t._v(" 意味着小于等于"),v("code",[t._v("c*n^2")])]),t._v(" "),v("p",[t._v("计算流程可以分为非递归算法和递归算法：")]),t._v(" "),v("ul",[v("li",[t._v("非递归算法 - 以插入排序为例子。递归计算为"),v("code",[t._v("1+2+...n=(1+n)*n/2")]),t._v("，根据大O表示法只保留算法的最高次幂，所以该算法就是一个"),v("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),t._v("复杂度的算法。")])]),t._v(" "),v("p",[v("strong",[t._v("递归算法的复杂度计算过程等我看完那门课程之后补充。")])]),t._v(" "),v("p",[v("strong",[t._v("算法复杂度之间关系：")])]),t._v(" "),v("ol",[v("li",[t._v("算法复杂度高也有高的好处，一般来说这个能够任意情况下适用。")]),t._v(" "),v("li",[t._v("从以上算法复杂度计算来看，可以看见算法复杂度和输入"),v("code",[t._v("n")]),t._v("有关，也就是"),v("strong",[t._v("数据规模")]),t._v("。有的时候算法复杂度比较低的算法在大规模数据的时候表现很好，但是在"),v("strong",[t._v("低规模的数据上表现就不一定有算法复杂度高的优秀。")])])]),t._v(" "),v("h2",{attrs:{id:"插入排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#插入排序"}},[t._v("#")]),t._v(" 插入排序")]),t._v(" "),v("p",[t._v("具体可见"),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-插入排序"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("计算复杂度："),v("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}})]),t._v(" "),v("h3",{attrs:{id:"实现流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现流程"}},[t._v("#")]),t._v(" 实现流程")]),t._v(" "),v("p",[t._v("流程可见下面"),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#/media/File:Insertion-sort-example-300px.gif",target:"_blank",rel:"noopener noreferrer"}},[t._v("GIF"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("strong",[t._v("引用至维基百科(从小到大排序)：")])]),t._v(" "),v("ol",[v("li",[t._v("从第一个元素开始，该元素可以认为已经被排序")]),t._v(" "),v("li",[t._v("取出"),v("strong",[t._v("下一个元素")]),t._v("，在已经排序的元素序列中"),v("strong",[t._v("从后向前")]),t._v("扫描 - 已经排序序列意思为下一个元素之前的元素")]),t._v(" "),v("li",[t._v("如果该元素(已排序，指的是第2步骤中下一个元素的之前元素与)大于新元素(指的是第2步骤上面下一个元素)，将该元素移到下一位置")]),t._v(" "),v("li",[t._v("重复步骤3，直到找到已排序的元素小于或者等于新元素的位置")]),t._v(" "),v("li",[t._v("将新元素插入到该位置后(此时该位置上元素比新元素小)")]),t._v(" "),v("li",[t._v("重复步骤2~5")])]),t._v(" "),v("p",[v("strong",[t._v("最差情况：")])]),t._v(" "),v("p",[t._v("元素原始是从大到小，期望从小到大排序。")]),t._v(" "),v("h2",{attrs:{id:"冒泡排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[t._v("#")]),t._v(" 冒泡排序")]),t._v(" "),v("p",[t._v("具体可见"),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-冒泡排序"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("算法复杂度和插入排序类似。有两种情况：")]),t._v(" "),v("ol",[v("li",[t._v("如果循环都是从头到尾的循环，那么就是"),v("code",[t._v("n*n")])]),t._v(" "),v("li",[t._v("如果是优化过后(排除末尾的元素)的就是"),v("code",[t._v("(1+n)*n/2")]),t._v(" - "),v("a",{attrs:{href:""}},[t._v("bubbleSort.js")]),t._v("实现的是优化过后的。")])]),t._v(" "),v("p",[v("strong",[t._v("引维基百科算法流程：")])]),t._v(" "),v("ol",[v("li",[t._v("比较相邻的元素。如果第一个比第二个大，就交换他们两个。")]),t._v(" "),v("li",[t._v("对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。")])]),t._v(" "),v("p",[t._v("第1步和第2步，可以视为是一个"),v("strong",[t._v("循环流程")]),t._v("，注意在一个循环过后，"),v("strong",[t._v("最后一个元素将会是最大的那个元素")])]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("针对所有的元素重复"),v("strong",[t._v("以上的步骤")]),t._v("，除了最后一个。")]),t._v(" "),v("li",[t._v("持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。")])]),t._v(" "),v("h2",{attrs:{id:"归并排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[t._v("#")]),t._v(" 归并排序")]),t._v(" "),v("p",[t._v("详见"),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-归并排序"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("归并排序思想在于将排序这个任分解为一个个小目标，每个小目标再一次分解，知道小目标只有一个。所以这个排序方法是"),v("strong",[t._v("非常适合递归")]),t._v("的排序方法。")]),t._v(" "),v("h3",{attrs:{id:"实现它"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现它"}},[t._v("#")]),t._v(" 实现它")]),t._v(" "),v("p",[v("strong",[t._v("引用维基百科算法流程：")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpeg",alt:"归并排序"}})]),t._v(" "),v("p",[t._v("从上图可以看出来是分为两个步骤："),v("strong",[t._v("大小比较在发生合并步骤中。")])]),t._v(" "),v("p",[t._v("以下是分解步骤：")]),t._v(" "),v("p",[t._v("按照图片中步骤"),v("strong",[t._v("分解")]),t._v("(递归方法)，一定能够分解为只有单个元素的数组。")]),t._v(" "),v("ol",[v("li",[t._v("递归边界 - 每个长度为1的数组")]),t._v(" "),v("li",[t._v("递归中 - 不断分解数组，分别为左边和右边。")])]),t._v(" "),v("p",[t._v("以下是合并的步骤(也处在递归中)，定义一个"),v("strong",[t._v("合并函数")]),t._v("：")]),t._v(" "),v("ol",[v("li",[t._v("申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列")]),t._v(" "),v("li",[t._v("设定两个指针，最初位置分别为两个"),v("strong",[t._v("已经排序")]),t._v("序列的起始位置")]),t._v(" "),v("li",[t._v("比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置")]),t._v(" "),v("li",[t._v("重复步骤3直到"),v("strong",[t._v("某一指针")]),t._v("到达序列尾")])]),t._v(" "),v("p",[t._v("因为对于合并步骤来说，需要进一步比较两个序列大小。属于一个个比较，然后较小的优先添加到新的数组里面。可能其中一个序列被优先添加完，所以要考虑这种情况下。将另一个序列的所有元素合并到新的数组中。")]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("将另一序列剩下的所有元素直接复制到合并序列尾")])]),t._v(" "),v("p",[t._v("然后返回这个数组，然后被上一步"),v("strong",[t._v("合并函数操作")]),t._v("，也是整个"),v("strong",[t._v("合并排序函数的返回值")])]),t._v(" "),v("h2",{attrs:{id:"快速排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[t._v("#")]),t._v(" 快速排序")]),t._v(" "),v("p",[t._v("算法复杂度只有"),v("code",[t._v("nlogn")]),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-快速排序"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("p",[t._v("算法流程为：")]),t._v(" "),v("ol",[v("li",[t._v("在一个数组中选择中元素作为主元("),v("code",[t._v("privot")]),t._v("，一般选择中间元素，表现最好)")]),t._v(" "),v("li",[t._v("设置两个指针，分别为"),v("code",[t._v("left&right")]),t._v("，分别指向数组开头末尾w。"),v("code",[t._v("left")]),t._v("指针指 "),v("strong",[t._v("第一个比主元大的元素")]),t._v("，"),v("code",[t._v("right")]),t._v("指向第一个比主元小得元素(如果想要从小到大排序)。如果"),v("code",[t._v("left")]),t._v("指针位置比"),v("code",[t._v("right")]),t._v("小("),v("strong",[t._v("比较指针位置并不是元素大小")]),t._v(")就交换这两个元素。直到"),v("code",[t._v("left")]),t._v("指针大于了"),v("code",[t._v("right")]),t._v("指针。")])]),t._v(" "),v("blockquote",[v("p",[t._v("经过step2，数组发生了什么(left到了right后面)，此时 **能够保证的是以left为界的左右两边数据，右边的大于左边。**但是没有办法保证left左边的数组的大小顺序。所以接下来要以"),v("code",[t._v("left")]),t._v("为划分两个数组的边界。进行step3。")])]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("以此时的"),v("code",[t._v("left.new")]),t._v("指针为界，和之前的"),v("code",[t._v("left.old")]),t._v("以及"),v("code",[t._v("right.old")]),t._v("来划分两个数组。对两边数组执行上面两个步骤相同的操作。因此是适合"),v("strong",[t._v("递归的算法")]),t._v("。")])]),t._v(" "),v("p",[v("strong",[t._v("问题在于？递归边界是什么？")])]),t._v(" "),v("p",[t._v("首先我们直接操作数组元素，并不需要"),v("code",[t._v("return")]),t._v("至上一步操作。所以没有"),v("code",[t._v("return")]),t._v("。")]),t._v(" "),v("p",[t._v("其次可以看到算法在不断划分数组，所以**边界应该是什么时候不需要划分数组。**但数组边界比不足以和之前的"),v("code",[t._v("left")]),t._v("或者"),v("code",[t._v("right")]),t._v("构成两个子数组。就停止这个快速排序的递归。")]),t._v(" "),v("h2",{attrs:{id:"实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("插入排序 - insertSort.js"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSorted.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("冒泡排序 - bubbleSort.js"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("归并排序 - mergeSort.js"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("快速排序"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=e.exports}}]);