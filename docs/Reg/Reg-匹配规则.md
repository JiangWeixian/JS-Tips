# 1. Reg - 匹配规则

<!-- TOC -->

- [1. Reg - 匹配规则](#1-reg---匹配规则)
  - [1.1. 模式](#11-模式)
  - [1.2. 规则](#12-规则)
    - [1.2.1. 分组 - 解释说明](#121-分组---解释说明)
    - [1.2.2. `?:` - 解释说明](#122----解释说明)
  - [1.3. 字符串转换为正则](#13-字符串转换为正则)
  - [1.4. Tips](#14-tips)
    - [1.4.1. 简单应用](#141-简单应用)

<!-- /TOC -->

## 1.1. 模式

可以写代表整个字符串格式的`reg`，或者写其中一部分格式`reg`并通过多次执行`.exec`来执行获取每一次匹配结果。

* i - 忽略大小写模式
* g - 全局，string.replace中用到的比较多，`replace`函数一般用的是`reg`匹配部分格式。

    > **如果正则是写整个字符串格式，就是获取全部分组结果** 例如在y模式举例的情况。

    > **如果正则是写一部分格式，可多次匹配`regex`整个表达式结果，可以通过多次执行`.exec`来获得不同结果**。

    > 与不是`g`模式的区别在于，没有`g`模式情况下 **多次`exec`还是只有一种结果。**
    
* m - 多行模式
* y - 粘性模式，这个比较难以理解

   > 如果开启这个模式！第二次执行结果在上一次基础上。例如`var regex = /(\w+):(\/{2,3})(\w+\.\w+\.\w+)/`匹配`var url = "http://xxx.domain.com"`。此时没有开启`y`，那么都是`url.match(regex)`第一次，以及再一次`regex.match(url)`中`match[1]`都是没有变得。但是开启了`y`之后，`match[1]`在不断变化，分别为第一次匹配结果以及第二次

   > **有限制使用的情况，默认是带有`^`**（也就是会限制字符串开头模式），例如如果对于`var str = "我的账户余额：2,235,467.20"`，`regex = /(\d{1,3})/`对于开启`y or g`时不同的情况。因为对于`y`必须以数字开头才能够匹配到规则。

## 1.2. 规则

* `[0-9]`等价`\d`，虽然是一句废话。但是有一个隐含的意思就是`[0-9]`**匹配是单个数字，并不是一组数字。**。所以想要匹配一组数字必须`[0-9]+ or \d+`
* **如果使用reg写出了整个表达式的结果。**，那么分组结果就已经确定了！不能再用`*?+`期望动态的分组结果。例如`/(\d{1,3},)*(\d{3})*(\.\d+)?/g`期望动态的`(\d{1,3},) or后面的`分组结果是做不到的。**想要动态的分组结果只能够用`reg`写出部分`str`格式。**
* 没办法做到匹配嵌套分组结果
* replace替换的是`match[0]` - 见下面的 **1.2.1. 分组 - 解释说明**。注意不是`match[1]`的分组结果。
* `?:` - 含义为不匹配分组，即如果`(?:xx)`那么匹配`xx`会进行匹配，但是不会出现在分组结果中。但是这个可以用于嵌套分组的匹配，例如 **?: 解释说明**

### 1.2.1. 分组 - 解释说明

* `var regex = /(\w+):(\/{2,3})(\w+\.\w+\.\w+)/` **整个表达式是一个匹配规则**
* `var match = url.match(regex)` - match可能为`0~xx`，即`match[0],match[1]...`

也就是说`url.match(regex)`我们想要的是对应`regex`规则的字符串。也就是`match[0]`，其中`value`为`http://xxx.domain.com`，因为这个`url`是符合`regex`规则的。

**而后面的match[1]...** 和`regex`密切相关，上图中一共三个分组，所以`match[1-3]`对应三个分组结果。

### 1.2.2. `?:` - 解释说明

> `?:` - 含义为不匹配分组。但是仅限于紧跟着`?:`之后的。例如[reg-url.js](https://github.com/JiangWeixian/JS-Tips/blob/master/docs/Reg/Reg-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99.md)

`(?::(\d+)) - 9090`，如果写成了`(?::\d+)`那么`9090`会 **进行匹配但是不会出现在match-list中**

由于`(\d+)`被`()`包裹，那么`:`(因为`:`跟着`?:`之后)不会出现在匹配结果 **仅仅只有:**。那么`9090`就会出现在match-list结果中。

作为对比，如果`(:\d+)`匹配的结果是`:9090`。

以上。

## 1.3. 字符串转换为正则

> 有些是函数参数要求是正则输入，但是如果不是正则输入的话。例如变为了字符串输入。那么字符串转换为正则通过`new Reg(xx)`

那么`new Reg('aa')`等价于`/aa/`。字符串转换为正则要避免以下的坑：

* 如果遇到属于正则关键字的，如`[] .`等需要转译，变为`\[\] \.`
* **转换过程中`\`会被认为是字符串`\`，而不是转译操作。** 所以第一点必须写成`\\[\\] \\.`

## 1.4. Tips

> 高级用法&容易忘记的地方

* 用好replace替换的是`match[0]` - 这一点很重要。
    * 因为结合`g`模式，进行多次匹配。实现多个替换。
    * 除此之外，并不意味这个`/xx/g`只能写一个分组，可以利用 **后一个分组来限制前一个分组的位置**，就像是`/(\d+)(?=((\d{3})+(?!\d)))/g`。**一般情况下会替换`match[0]`也就是整个表达式结果** 如果只想要替换`(\d+)`，那么就应该使用`string.replace`的更多参数控制分组结果，甚至可以使用 [**回调函数**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0)
* `\w`意味着`[a-zA-Z0-9_]`而不仅仅只是字母

### 1.4.1. 简单应用

* [例子链接](https://github.com/JiangWeixian/JS-Tips/blob/master/docs/Reg/Reg-%E5%85%A8%E9%83%A8%E5%8C%B9%E9%85%8D%E5%AE%9E%E4%BE%8B.md)