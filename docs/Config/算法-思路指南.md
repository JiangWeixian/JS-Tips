# 1. 算法思路
> 经验有限；只能够给自己说明白，能知道解法也就下面这些。以后看了算法公开课再来补充。

<!-- TOC -->

- [1. 算法思路](#1-算法思路)
  - [1.1. 一句话](#11-一句话)
  - [1.2. 递归](#12-递归)
    - [**递归特点：数据传递**](#递归特点数据传递)
    - [**递归特点：书写**](#递归特点书写)
  - [1.3. 动态规划](#13-动态规划)
  - [1.4. 两个指针](#14-两个指针)

<!-- /TOC -->

## 1.1. 一句话

学好数学，其实这些都是有数学理论支撑的。我看了网易公开课前面几集的结论。

## 1.2. 递归

> **先不考虑性能问题**，递归好理解但是性能有问题需要优化

1. 其实递归有递归表达式，例如求解`[1, 1, 2, 3, 5...]`此类后一个是前两个相加结果。

那么递归表达式解释`f(n)=f(n-1)+f(n-2)`，有没有发现其实这就是一个数学公式！！以前上学的时候怎么不知道这个解法。

再比如求解阶乘，`!n=n*n-1*n-2...*1`。可以理解为`f(n)=n*f(n-1)`。

递归需要考虑2个问题：

1. 在递归边界外(例如上面式子成立条件是`n>=0`，所以要在`n<=2`)中止递归
2. 在递归边界内求解递归(就是上面那个表达式)`f(n)=f(n-1)+f(n-2)`

转化为具体的代码为：

```JavaScript
// 先写出f(n)
function f (n) {
  // 递归边界外
  if (n <= 2) {
    return 1
  }
  // 递归边界内
  return f(n-1) + f(n-2)
}
```

**是不是还挺好理解的**(没有递归表达式(或者是不太直观的)，这个一点点补充)

### **递归特点：数据传递**

其实发现递归有些共同特点，在调用自身背后。我发现无论是 **是否利用上一个函数调用结果** 有些们不太注意的细节。就是一定 **有一个数据在递归中传递的。**

> 需要利用到上一个函数结果，来改变当前结果。然后返回当前结果。那么 **函数结果在作为数据传递。**。

> 类似树的递归，其实是 **树是引用类型，在递归过程中是做出的动作是会反应到树结构中！那么应用类型是作为数据传递的一部分。**

> 类似尾递归优化，每次递归结果是作为 **函数参数传递的** 也不违背规律。


### **递归特点：书写**

1. 可以是`f(n)=f(n-1)+f(n-2)`当前步骤需要上一个结果
2. 或者像是[二分查找递归](https://github.com/JiangWeixian/JS-Tips/blob/master/Grammar/JS-Array-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md)那样，当前步骤简化便于下一步骤求解
3. 在[22括号生成]()提供了动态递归的思路

## 1.3. 动态规划

> 和递归一样也是有一定数学理论

高中数学或者初中数学有一个很重要的推导方法。想要证明一个式子成立：

1. `f(1)`成立，这是基础
2. 假设`f(n-1)`成立
3. 如果在`f(n-1)`成立基础上`f(n)`成立，那么`f(n)`这个表达式成立

动态规划类似，它假设

1. `f(1)`有最优解
2. `f(2)`在`f(1)`最优解基础上得到最优解

然后一直推导到最后一个`f(n)`

没错这个还是有递归...。但是 **最优解以及当前函数需要利用到上一个函数结果是它的特点。**

* 最小化能求解的到最优解，假设是`f(1)`
* 结果返回上一步，即求解`f(2)`得到`f(1)`求解过程。然后利用`f(1)`结果得到`f(2)`。

依次类推，然后得到最终要求解的`f(n)`

## 1.4. 两个指针

> 因为我发现这个还能解决蛮多问题的

来源于[JS-快速排序算法.js](https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.js)。有事没事头尾设置两个指针看看能不能简化你的问题。