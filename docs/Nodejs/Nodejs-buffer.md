# Nodejs - Buffer
> 入门基础级别

<!-- TOC -->

- [Nodejs - Buffer](#nodejs---buffer)
  - [前置知识 - Buffer存储约定](#前置知识---buffer存储约定)
  - [前置知识 - 编码](#前置知识---编码)
  - [细节](#细节)
  - [链接](#链接)

<!-- /TOC -->

## 前置知识 - Buffer存储约定

`Buffer`是一个类数组格式。数组每一个元素都是一个字节，**一个字节就是`8bits`**。也就是`0000 0000`。

也就是意味着如果`0000 0000`表示为数字就是`0-255`。这里要区分一个概念，就是真正的数字和这里的`0-255`。**真正的数字是8个字节，而Buffer数字意味编码表的`index`。**

如果将数字传递给`Buffer`

```JavaScript
Buffer(10) // 创建10个字节buffer
Buffer.alloc(10, 1) // 10个字节，并以数字1初始化。1转化为二进制为 0000 0001。代表编码表index
Buffer.from([1, 2, 3]) // 此时1,2,3同样也是编码表index。所以数字不能够超过255
```

可以发现`Buffer`并没有直接操作数字的操作。如果初始化为字符串。

`Buffer.alloc(10, 'a')`。其中`a`编码`index=97`。

而对于`Buffer.from('hello')`，会分割每一个字母，然后由于英文字母`index`不会超过255。所以一个字母对应一个字节。存储也没有问题。

## 前置知识 - 编码

> 在[前置知识 - Buffer存储约定](#前置知识---buffer存储约定)中是`ascii`的编码表，就像是`a`编码`index=97`。

> 编码就是如何处理字节，字符；只有在涉及字符串的时候才有编码，数字的话就是一个字节value。和编码没有关系

> 无论编码格式如何，都是一个字节一个字节存储，变的是多个字节才能表示一个原始数据

**简单说明几个编码格式**

* `utf-8` - 多字节编码，每个字符的代表的字节是不一定的。中文可能是多个字节，单个英文字母是一个字节(可能会认为一个中文类比一个英文字母吧)。

    > 其实这就涉及到了计算机如何判断多少个字节是一个字符的问题？一般我们创建`buffer`指定了编码格式，那么`buffer->string`的过程中，就会以编码的方式看待字节。通过一些标志位来判断字节连续性。 例如存在一个`urf-8`编码表，一个`index`对应一个字符(可以英文或者中文)，那么多个字节得出的`index>255`自然也就可以表示超过英文字母的表示了。**一般存储以及`toString`表示需要设定同一个编码格式。**

    > 那么字符串到`buffer`是如何处理的？`Buffer.from('hello', 'utf-8')`。**utf-8编码表是`(index, value)`格式，`index`可以超过255**。对于每个 **单个字母** 通过`value`找到`index`，如果`index<255`，那么表示为一个字节。如果`index>255`的话就是多个字节(毕竟一个字节无法表示)。**utf-8 index需要包含字节序控制**

* `hex` - 单字节编码，一个字节8bit，可以表示为两个16进制数字。例如`1`可以是`0001`，此时不足一个字节，一个字节的话就是`0000 0001`。

    > 也就是说，`hex`遇到单个字符会通过`index, value`方式，将找到的`index`变为4bit。可是没有半个字节存储的数据。所以`hex`会读两个字符 **拼接为`8bit`**。
    
    就像是`Buffer.from('74')`。显示遇到`7->0111`(`index`也是`7`)，`4->0100`。那么`buffer`存储结果就是`0111 0100`。假设我们通过`ascii`来`toString`，显然会一个个字节读取，而不是`hex`半个字节读取。**一定会出错的！**

除了通过编码控制读取字节，还可以通过接口还是来控制一次性读取几个字节。

## 细节

* `Array.from()` - 如果传递`buffer`是复制不共享，如果是`arraybuffer(!=array)`是共享的。


## 链接

* [编码链接](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)