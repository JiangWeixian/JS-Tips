# 浮点数陷阱

## 前置知识 - JS中的数据存储

可以先看看我关于[大整数](https://github.com/JiangWeixian/JS-Tips/blob/master/Grammar/JS-%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0.md)的总结。

## 前置知识 - 什么是浮点数陷阱？

一行代码表示`0.1+0.2===0.3`会是`false`

而`7*0.8`最后结果是`5.6000000000000005`。

上诉两个都是非常让人感到疑惑。

因为不符合认知。

在`MDN`中`Number`有一个函数获得一个数字在存储中的真实表示：

```JavaScript
var numObj = 0.8;
console.log("numObj.toPrecision()  is " + numObj.toPrecision());  //输出 0.8
console.log("numObj.toPrecision(3) is " + numObj.toPrecision(3)); //输出 0.800
console.log("numObj.toPrecision(2) is " + numObj.toPrecision(54)); //输出 0.800000000000000044408920985006261616945266723632812500
```

可以得到一个结论，其实我们看的`0.8`可能后面带着一串 **不知道来自哪里的数字，就像是上面一样**，只是我们看不见而已。才会出现上面的`bug`

**当我们使用：**

```JavaScript
0.800000000000000044408920985006261616945266723632812500 * 7 // 结果就是5.6000000000000005
```

现在来到了为什么`0.8`会出现以上哪种行为？首先我么要知道

> 而JS在计算过程中总是先转换为二进制->在实现二进制相加(或者相乘)->再转换为10进制，**再因为浮点数显示长度限制，只有前多少位的二进制数字才能够被转换为10进制。才有了上面不符合认知的情况**

而`0.8`转化为二进制形式为`0.1100110011001100110011001100110011001100110011001101`。此时我们来手动计算一下`0.8`的转换为二进制的情况：

```JavaScript
0.8 * 2 = 1.6 // 1....0.6
0.6 * 2 = 1.2 // 1....0.2
0.2 * 2 = 0.4 // 0....0.4
0.4 * 2 = 0.8 // 0....0.8
0.8 * 2 = 1.6 // 1....0.6
//可以发现，接下来就是一个无线循环1100的过程
```

**所以如果计算存储的位数够多，`0.8`的二进制表示应该是无限循环的数字。但是我们只能够存储其中一部分，然后转换为10进制的时候，也就导致了出现0.8后面多了一串奇怪的东西** 这就是为什么会出现浮点数陷阱。

完整解析见[@camsong-浮点数陷阱](https://github.com/camsong/blog/issues/9)

## 解决 - 如何得到精确的计算结果

有很多解决方案

1. 像python那样使用`numpy`的库
2. 如果仅仅是判断两个数字是否相等，可以通过`Number.EPSILON`属性，判断两个数字如果差值在这个范围内的话，就返回是相等。

但是如果我们真的是想要一个计算结果，相对准确的那种。

可以参考这里的[总结](http://www.css88.com/archives/7340)。大致思路也就是

1. 先变为整数(比如说乘以1000之类)，不要小数再计算
2. 最后才除以1000