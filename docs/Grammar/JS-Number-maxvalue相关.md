# JS - Number
> masvalue&maxsafevalue

<!-- TOC -->

- [JS - Number](#js---number)
  - [前置知识 - 二进制转化](#前置知识---二进制转化)
  - [前置知识 - JS数据存储](#前置知识---js数据存储)
  - [MAX_SAFE_INTEGER](#max_safe_integer)
    - [相关操作](#相关操作)
  - [MAX_VALUE](#max_value)
  - [MIN_VALUE](#min_value)
  - [总结](#总结)

<!-- /TOC -->

## 前置知识 - 二进制转化

如果不需要明白转换原理

```JavaScript
var num = 4
num.toString(2) // 100
var num = 0.1
num.toString(2) // 0.1
```

**题外话 - 具体转换公式**

如果是`4`的话

```JavaScript
4 / 2 // 2...0(分别是商和余数)
2 / 2 // 1...0
1 / 2 // 0...1 由于商为0了，所以停止计算
```

如果是`0.5`的话

```JavaScript
0.5 * 2 // 1...0(分别是小数点前面和后面)，由于小数点后面是0了，所以停止计算
```

## 前置知识 - JS数据存储

> 计算机都是二进制存储

数据8个字节，每个字节8bit，一共64bit。

* 1个符号位 - 这个好理解，就是正负
* 11个指数位
* 52个尾数位

**以一个例子说明JS数据存储形式：**

理解[@camsong浮点数](https://github.com/camsong/blog/issues/9)

1. `4.5`会变为`100.1`，其中`100`为`4`，`0.1`就是`0.5`的数据存储
2. 对于`100.1` **在JS中数字都会转化为上面格式的二进制表示为`1.001*2^2`**，`1.001`是二进制，而`2^2`是二进制形式的指数表达，可以理解为10进制的`10^2`。**也就是小数点向后移动两个位置的形式**

    ![存储格式](https://user-images.githubusercontent.com/948896/31601584-f65ed43e-b21f-11e7-8755-c99b48e5134c.png)

    对应`1.001`，符号位是`S=0`，尾数位是`M=001`，指数位置是`2`(指数部分此时还不是bit形式，但是对于bit尾数有特别意义)。符号位很好理解，主要是这个`001`[尾数位]()。
    
**尾数位**

> 首先要知道尾数其实是小数点后面的数字

**在JS中1.001前面的1不保存(转换好尾数再默认添加即可)**，也就是上图中(`M+1`)的含义。也就是说`52`位置都是用来保存尾数的。

也就是说`001`后面还有`0000...0000`共`49`个。合计52个。

那么对于`4.5`来说就是`1 x 2^2 x (001 + 1)`，`001 + 1`等价于`1.001`，但是 **注意这个`1`是不存储的**

以上面格式存储之后，转换为10进制需要经过：

1. `001 + 1`等价于`1.001`
2. `1.001 x 2^2`等价于`100.1`
3. `100.1`转换为10进制

[@camsong浮点数](https://github.com/camsong/blog/issues/9)还提到了如何将小数转换为`1.xxx`这样的格式。

> 由于小数转换为二进制可能出现无线循环的情况，见[JS-浮点数陷阱]()。而由于尾数位数的限制，所以会截断部分，使得二进制表示是不完整的，最终转换为10进制的时候进行其他计算的时候，就会出现误差。

**指数位**

> 2^(xxx)指数位指的是`xxx`的数字部分。也就是`xxx`如果是二进制表示的话，只能够是`11`位。(xxx)指的是`E-1023`

由于指数可以是负数，所以`11`位的`xxx`第1位是符号位，后面10位才是真实数字。范围就是(-1023, 1023)之间。(在二进制中)**正的代表小数点对于`1.001`来说，需要小数点向右边移动位置，负的就是小数点向左边移动。**

**这里我指的都是，注意是`xxx(E-1023)`的范围**，严格来说，计算机表示的是`E的范围`。

## MAX_SAFE_INTEGER

> 表示的最大正整数，和尾数相关

在[前置知识 - JS数据存储]()提到，尾数可以保存52位。

**最大正整数**含义为，尾数部分没有小数部分(`1.001`需要变为`100.1`就表示有小数部分)

那么最大就是尾数部分全部都是`1`，一共`52`个，为`1.111111.....111`，尾数部分`52个1`。

`1.111111.....111`全部表示正数，(没有小数部分，全部代表小数点前面的数据)也就是可以转换为`1111111.....111`共`53`个。(虽然第一个位置`1`不存储，但是在转换为10进制的时候，还是要加上)

可以计算得到`2^52+....2^0`等于`2^53-1`，就是`Number.MAX_SAFE_INTEGER`

**MIN_SAFE_INTEGER就是负数的MAX_SAFE_INTEGER**

### 相关操作

> 记录和`MAX_SAFE_INTEGER`相关问题

1. BUG1

MAX_SAFE_INTEGER = 2^53-1

如果一个数字等于`2^53`，那么`2^53+1`还是等于`2^53`。**如果用在循环上，可能导致死循环。**。而且如果不加上`1`，而是一下子加了一个比较大的数字，数值变化了，但是结果不对。因所以`MAX_SAFE_INTEGER`范围之内，结果才会比较准确。

可是如果是乘法却又不会，例如`2^53*num(>1) != 2^53`。

## MAX_VALUE

> 大于`MAX_SAFE_INTEGER`。

在[MAX_SAFE_INTEGER]()，对于`1.111111.....111`(**全部转换位小数点前面的数据**)，需要将小数点向右移动52个位置。也就是`1.111111.....111 * 2^52`，注意`2^52`是对于`bit`操作才是移动位置。

**细节部分**

```JavaScript
// 以下面举例
1. 001 + 1等价于1.001
2. 1.001 x 2^2等价于100.1
3. 100.1转换为10进制

// 第三步
2^2+0+0+2^-1 = 4.5
```

如果从第二步骤开始：

```JavaScript
2. 1.001 * 2 ^ 1 * 2 ^ 1 等价于 10.01 * 2^1 // 此时如果直接将10.01跳到第三步
3. 10.01等于10进制的2.25 // (2^1*1 + 0 + 0 + 2^-2*1)

// 那么剩余的2^1不再是相对于二进制的移动小数点操作
// 而是2.25直接乘以2 = 4.5
// 可以测试以下1.001转化为10进制之后，然后再乘以2^2
```

所以对于`MAX_VALUE = 1.111111....111 * 2^1023`来说，等价于`MAX_VALUE = 1.111111....111 * 2^52 * 2^971`。其中`1.111111.....111 * 2^52`转换为10进制表示为`MAX_SAFE_INTEGER`，也就是说：

```JavaScript
MAX_VALUE = 1.111111....111 * 2^1023 = MAX_SAFE_INTEGER * 2^971 = MAX_SAFE_INTEGER * Math.pow(2, 971) 
// 最后一个等式，根据上面的理论就是10进制的操作
```

**大于MAX_VALUE就是无穷**

## MIN_VALUE

> 并不是负数的`MAX_VALUE`，含义为最接近0(但是大于0)的正数，说明是个小数

`MIN_VALUE`等于`5e-324`，等于`Math.pow(2, -1075)`

可以预知`.000000...001`是 **尾数部分**最小表示，且这是一个小数。转化为10进制就是：

```JavaScript
0....+0+2^-52*1 = 2^-52 // 此时小数点前面是0？这一点我一直不太好理解...
```

那么`MIN_VALUE = 2^-1023 * 2^-52`

## 总结

将几个内置的数据排序在坐标轴上，可以得到：

```JavaScript
-MAX_VALUE -MAX_SAFE_INTEGER -MIN_VALUE MIN_VALUE MAX_SAFE_INTEGER MAX_VALUE
```

在`-MAX_VALUE`左边就是负无穷，在`MAX_VALUE`右边就是正无穷

