# Vue - vuex
> 相比于怎么用；为什么使用可能才是你比较关心的问题

<!-- TOC -->

- [Vue - vuex](#vue---vuex)
  - [**`Vue` - 状态管理**](#vue---状态管理)
    - [**不使用`vuex`**](#不使用vuex)
    - [**使用`vuex`**](#使用vuex)
  - [`vuex`设计思想](#vuex设计思想)
  - [**链接**](#链接)

<!-- /TOC -->

## **`Vue` - 状态管理**

> vuex公共状态关系

这可能是你见到的最直接的答案，但是很抽象。因为对于`vue`来说可以实现 **父子类通信以及兄弟节点之间的通信(通过传递到共有的父类上，然后订阅这部分共有数据即可)**，如何实现见[Vue-组件通信](https://github.com/chenbin92/blog/issues/1)。

甚至可以说`vue-router`页面跳转，页面之间的数据传递也可以由一个父类进行控制。

可以发现，不通过`vuex`也能够实现共同状态管理。**所以`vuex`进行公共状态管理的回答不够准确。**

### **不使用`vuex`**

不使用`vuex`的情况相对来说更好举例：

1. 如果组件专注于`UI`层的话，**显然我们不需要`vuex`**
2. 如果页面数据来自服务器，一个页面地址对应一个状态，那么 **我们不需要`vuex`**

    > 通常做法是父类获取数据，来渲染到不同子类上
    
3. 如果页面解构简单，就像是[**`Vue` - 状态管理**](#vue---状态管理)里面提到的通信情况，其实并没有涉及层级超过1个的组件通信。**此时也不需要`vuex`进行控制**

    > 也就是说子类到父类，数据传递层级只有1；两个兄弟节点的通信，也只是将兄弟节点数据传递给共有的父类，然后父类通过`props`进行数据传递。

当然你也可以使用，我们 **不使用的目的是为了让页面体积更小。**

### **使用`vuex`**

> 什么情况下适合`vuex`使用；vuex公共状态关系依旧是最为明显好处

使用`vuex`那肯定是因为它给我们带来了好处。设想以下场景：

1. 多层级嵌套 - 父类嵌套子类，子类同时又嵌套一个子子类。那么子子类传递到父类，如果是`on emit`方法，那么就会出现 **子子类emit子类，子类emit父类这样的方式进行数据一层层传递。** 显然 **此时有`vuex`会更为合理一些**，公共数据管理的好吃就比较明显了。

2. 减少请求 - 存在向服务器发送请求的情况，以我仿写网易云音乐的工程为例子，获取用户歌单数据，用户渲染歌单数据部分。这部分数据在多个页面中使用。

    > 对于不太复杂的情况，例如父类获取数据，传递给子类。此时简单的`props`就可以实现。

    > 但是 **多级别嵌套情况出现之后**，除了`vuex`带来的共有数据管理利于组件之间数据传递之外。我们同样也避免了相同数据的服务器请求。

3. 数据同步 - `vuex`数据是同步，改变同样触发监听该部分数据的组件

## `vuex`设计思想

> 为啥设计为`state action mutation getters`

其实`state action...`等都有对应的`mapState mapAction`的对应方法，因此在`vue`组件中如果想要获取`state`，完全可以通过`mapState`导入`state`，而不需要经过`mapGetter`。

**那么就会出现一个问题，为啥出现除了`state`之外的几个接口函数。**

`vuex`约定俗成的概念是，`state`的改变是通过`mutation`触发，`mutation`是同步的修改`state`操作，而`actions`则是异步的修改`state`操作。

> 在适合使用`vuex`的工程前提下

1. `mutations or actions`作用相对好理解

    > ([文档](https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8)中有提到)接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。

    > 而异步和同步的操作写在两个地方也是出于操作分类的目的。因为虽然`actions`属于异步，但是`actions`中修改`state`操作还是借由触犯`mutation`实现。

2. `getters`类比组件中`computed` - 一部分由于`vuex`是全局的，`getters`也是全局的；另一部分，出于 **复用** 计算`state`的目的以及`state`需要经过计算处理，所以我们会将一些属性放在`getters`进行获取。

    > 所以可以得到结论，如果你不需要`computed state`，自然可以不通过`state`获取数据。而是直接通过`mapState`将数据导入组件

## **链接**

* [父子间通信于`vuex`](https://juejin.im/post/592702c12f301e006c2a28a0)
* [如果不使用`vuex` - 复杂组件通信状态](https://www.cnblogs.com/forzhaokang/p/8317987.html)
    