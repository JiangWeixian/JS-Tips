(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{217:function(e,t,v){e.exports=v.p+"assets/img/lifecircle.fba2949b.png"},485:function(e,t,v){"use strict";v.r(t);var _=v(0),o=Object(_.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"react源码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react源码"}},[e._v("#")]),e._v(" React源码")]),e._v(" "),_("blockquote",[_("p",[e._v("生命周期；以及Diff算法&VD分析；"),_("strong",[e._v("Diff算法")])])]),e._v(" "),_("h2",{attrs:{id:"生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" "),_("strong",[e._v("生命周期")])]),e._v(" "),_("p",[_("img",{attrs:{src:v(217),alt:"生命周期"}})]),e._v(" "),_("p",[e._v("可以将生命周期分为两个阶段，分别是"),_("code",[e._v("mount")]),e._v("以及"),_("code",[e._v("re-render")]),e._v("阶段。")]),e._v(" "),_("ol",[_("li",[_("code",[e._v("mount")]),e._v(" - 只会在第一次渲染的时候执行一次")]),e._v(" "),_("li",[_("code",[e._v("re-render")]),e._v(" - 会因为"),_("code",[e._v("state or props")]),e._v("更新执行多次")])]),e._v(" "),_("p",[e._v("最后一个阶段是"),_("code",[e._v("unmounting")]),e._v("阶段。")]),e._v(" "),_("blockquote",[_("p",[e._v("要注意，这里的"),_("code",[e._v("mount rerender unmount")]),e._v("阶段意味着很多钩子函数的出发")])]),e._v(" "),_("p",[_("strong",[e._v("注意：")]),e._v(" 图中"),_("code",[e._v("this.setState")]),e._v("被划掉意味着最好不要在这里调用"),_("code",[e._v("setstate")]),e._v("。那么其实只有"),_("strong",[e._v("willmount and receiveprops")]),e._v("钩子函数最好使用"),_("code",[e._v("setstate")]),e._v("。")]),e._v(" "),_("blockquote",[_("p",[e._v("个人理解如果你在"),_("code",[e._v("didmount")]),e._v("调用"),_("code",[e._v("setstate")]),e._v("会触发"),_("code",[e._v("rerender")]),e._v("但是不会循环。因为属于"),_("code",[e._v("mount")]),e._v("阶段的钩子函数只会调用一次。如果你"),_("code",[e._v("setstate")]),e._v("，那么接下来的"),_("code",[e._v("rerender")]),e._v("应该就是"),_("code",[e._v("rerender")]),e._v("阶段的事情了。")])]),e._v(" "),_("blockquote",[_("p",[e._v("不过如果你在"),_("code",[e._v("rerender")]),e._v("阶段的钩子函数里面调用"),_("code",[e._v("setstate")]),e._v("(除了"),_("code",[e._v("receiveprops")]),e._v("函数)，那么可能会可能会导致循环消耗内存。")])]),e._v(" "),_("p",[_("strong",[e._v("在其余钩子函数里面调用"),_("code",[e._v("setstate")]),e._v("可能会引起循环的更新。")]),e._v(" 原因是因为 "),_("strong",[_("code",[e._v("willmount receiveprops")])]),e._v(" 两个钩子函数的调用"),_("code",[e._v("setstate")]),e._v("会合并"),_("code",[e._v("state")]),e._v("。")]),e._v(" "),_("h2",{attrs:{id:"setstate"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[e._v("#")]),e._v(" setstate")]),e._v(" "),_("ul",[_("li",[e._v("在"),_("code",[e._v("mount")]),e._v("阶段调用的"),_("code",[e._v("setstate")]),e._v("会合并到一处进行更新。除非这个"),_("code",[e._v("setstate")]),e._v("是异步的方式。也就是非异步和异步是两个"),_("code",[e._v("setstate")]),e._v("的调用栈。")])]),e._v(" "),_("blockquote",[_("p",[e._v("可以理解为"),_("code",[e._v("rerender")]),e._v("阶段的"),_("code",[e._v("setstate")]),e._v("是及时的。然而"),_("code",[e._v("mount")]),e._v("是"),_("code",[e._v("batch")]),e._v("合并的。而"),_("code",[e._v("mount")]),e._v("得异步则进入了"),_("code",[e._v("rerender")]),e._v("阶段吗？")])]),e._v(" "),_("h2",{attrs:{id:"diff"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#diff"}},[e._v("#")]),e._v(" diff")]),e._v(" "),_("p",[e._v("原则")]),e._v(" "),_("ul",[_("li",[e._v("不同组件只会删除和创建")]),e._v(" "),_("li",[e._v("同一层级的组件会进行diff算法")]),e._v(" "),_("li",[e._v("跨层级的被"),_("code",[e._v("react")]),e._v("的忽略了，因为会比较少")])]),e._v(" "),_("p",[e._v("特点：")]),e._v(" "),_("ul",[_("li",[e._v("好像之后移动操作，没有前移操作\n"),_("blockquote",[_("p",[e._v("好像的确是这样，对于同一层级")])])])])])}),[],!1,null,null,null);t.default=o.exports}}]);